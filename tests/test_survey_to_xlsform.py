'''
.. module:: test_survey_to_xlsform
    :Date: 2014/09/16
    
.. codeauthor:: Esmail Fadae <esmail.fadae@kobotoolbox.org>
'''


from __future__ import absolute_import

import unittest
import os.path
from tempfile import NamedTemporaryFile

from .. import survey_from
from .. import constants
from ..section import GroupedSection
from pyxform import survey_to_xlsform


class Test_SurveyToXlsForm(unittest.TestCase):

    def setUp(self):
        unittest.TestCase.setUp(self)
        
        # Record the path to all files in the 'example_xml' directory.    
        test_directory_path= os.path.dirname(__file__)
        self.xform_directory_path= os.path.join(test_directory_path, 'example_xforms')
        
        self.xform_in_paths= [ os.path.join(self.xform_directory_path, filename) \
                        for filename in os.listdir(self.xform_directory_path)]


    @staticmethod
    def _export_and_reimport(original_survey, export_format='xls', warnings=None):
        '''
        Given a survey, export it in the format specified and return a 
        re-imported version of it
        
        :param pyxform.survey.Survey original_survey:
        :param str export_format: The desired intermediate file export_format. Either 'xls' (default) 'csv', or 'xform'.
        :param list warnings: Optional list into which any warnings generated during import/export will be appended.
        
        :returns: An exported and re-imported version of the survey.
        :rtype: pyxform.survey.Survey
        '''
        
        with NamedTemporaryFile(suffix='-pyxform.'+ export_format) as xlsform_tempfile:
            # Export the survey to file and re-import it.
            if export_format.lower() == 'xls':
                original_survey.to_xls(xlsform_tempfile.name, warnings=warnings)
                reimported_survey= survey_from.xls(xlsform_tempfile, warnings=warnings)
            elif export_format.lower() == 'csv':
                original_survey.to_csv(xlsform_tempfile.name, warnings=warnings)
                reimported_survey= survey_from.csv(xlsform_tempfile, warnings=warnings)
            elif export_format.lower() == 'xform':
                original_survey.to_xform(xlsform_tempfile.name, warnings=warnings)
                reimported_survey= survey_from.xform(xlsform_tempfile, warnings=warnings)
            
            return reimported_survey


    def test_consistent_export(self):
        '''
        Test that exporting a form to CSV and XLS results in the same data.
        '''
                
        for xform_in_p in self.xform_in_paths:            
            # Import and store the XForm.
            xform_survey= survey_from.xform(xform_in_p)
            
            xls_survey= self._export_and_reimport(xform_survey, 'xls')

            csv_survey= self._export_and_reimport(xform_survey, 'csv')

            self.assertEqual(xls_survey, csv_survey, 'XLS and CSV XLSForm mismatch for "{}".'.format(xform_in_p))


    def test_unicode(self):
        '''
        Test that Unicode text is correctly exported and re-importable.
        '''
        
        expected_question_label= u"Don't you just \u2764 Unicode\u203d"
        
        # Get the Unicode survey's absolute path.
        unicode_survey_path= os.path.join(self.xform_directory_path, 'unicode_survey.xml')
        
        xform_survey= survey_from.xform(unicode_survey_path)
        
        # Test XLS re-import.
        xls_survey= self._export_and_reimport(xform_survey, 'xls')
        
        # Check that the first question's Unicode label was preserved.
        xls_question_label= xls_survey[constants.CHILDREN][0][constants.LABEL]
        self.assertEqual(xls_question_label, expected_question_label)


    def test_all_question_types_kf2(self):
        '''
        Test that all question types generated by KoBoForm 2 can be exported 
        and re-imported correctly.
        '''
        
        from pyxform.aliases import get_xform_question_type # Used by this test only (currently)

        expected_child_info= \
          [(u'Select_One_question', u'select one'),
           (u'Select_Many_question', u'select all that apply'),
           (u'Text_question', u'text'),
           (u'Number_question', u'integer'),
           (u'Decimal_question', u'decimal'),
           (u'Date_question', u'date'),
           (u'Time_question', u'time'),
           (u'Date__Time_question', u'dateTime'),
           (u'GPS_question', u'geopoint'),
           (u'Photo_question', u'image'),
           (u'Audio_question', u'audio'),
           (u'Video_question', u'video'),
           (u'Barcode_question', u'barcode'),
           (u'Acknowledge_question', u'acknowledge'),
           (u'start', u'start'),
           (u'end', u'end'),
           (u'deviceid', u'deviceid'),
           (u'meta', u'group')]

        # Import the XForm then export it to XLS and re-import the XLSForm.
        xform_survey= survey_from.xform(os.path.join(self.xform_directory_path, 'all_question_types_survey_kf2.xml'))
        xls_survey= self._export_and_reimport(xform_survey, 'xls')

        for i, (xform_child, xls_child) in enumerate( zip(xform_survey['children'], xls_survey['children']) ):
            expected_name, expected_type=  expected_child_info[i]
            
            self.assertEqual(xform_child['name'], expected_name)
            self.assertEqual(xls_child['name'], expected_name)
            
            # Check that the types from the imports all de-alias to the same thing as the expected types.
            self.assertEqual(get_xform_question_type(xform_child['type']), get_xform_question_type(expected_type))
            self.assertEqual(get_xform_question_type(xls_child['type']), get_xform_question_type(expected_type))


    def test_question_types_imported_in_order_kf1(self):
        '''
        tests the order and types match the expected output for a KoBoForm 1 
        XForm.
        '''
        
        expected_qtypes_list = \
          [(u'deviceid', u'deviceid'),
          (u'start', u'start'),
          (u'end', u'end'),
          (u'Select_One_question', u'select one'),
          (u'Select_Many_question', u'select all that apply'),
          (u'Text_question', u'string'),
          (u'Number_question', u'int'),
          (u'Decimal_question', u'decimal'),
          (u'Date_question', u'date'),
          (u'Time_question', u'time'),
          (u'Date__Time_question', u'dateTime'),
          (u'GPS_question', u'geopoint'),
          (u'Photo_question', u'image'),
          (u'Audio_question', u'audio'),
          (u'Video_question', u'video'),
          (u'Barcode_question', u'barcode'),
          (u'Acknowledge_question', u'acknowledge')]
        
        survey = survey_from.xform(os.path.join(self.xform_directory_path, 'all_question_types_survey_kf1.xml'))
        question_types_list = list()
        for q in survey['children']:
            question_types_list.append( (q['name'], q['type']) )
        self.assertListEqual(question_types_list, expected_qtypes_list)


    def test_translations(self):
        '''
        Test that XForms with translations can be imported successfully and that 
        the translations can be exported to a XLSForm.
        '''
        
        xform_survey_translated= survey_from.xform(os.path.join(self.xform_directory_path, 'all_question_types_survey_kf1_translations_inserted.xml'))
        xlsform_survey_translated= self._export_and_reimport(xform_survey_translated, 'xls')
        
        for xform_child, xlsform_child in zip(xform_survey_translated['children'], xlsform_survey_translated['children']):
            # Only check children (questions) with labels.
            if xform_child.get('label'):
                xform_label_english= xform_child['label']['English']
                xform_label_not_english= xform_child['label']['Not_English']
                self.assertEqual('(Not_English) ' + xform_label_english, xform_label_not_english)
    
                xlsform_label_english= xlsform_child['label']['English']
                xlsform_label_not_english= xlsform_child['label']['Not_English']
                self.assertEqual('(Not_English) ' + xlsform_label_english, xlsform_label_not_english)
                
                self.assertEqual(xlsform_label_english, xform_label_english)
                self.assertEqual(xlsform_label_not_english, xform_label_not_english)


    def test_cascading_select_graceful_failure(self):
        '''
        Test that when cascading-select questions are encountered while exporting
        to XLSForm, though the question question_choices can't be imported, a descriptive 
        failure message is inserted into the resulting file and that the file 
        is valid for re-import.  
        '''
        
        from pyxform.question import MultipleChoiceQuestion
        from pyxform.survey_to_xlsform import XlsFormExporter
        
        survey_original= survey_from.xls(os.path.join(self.xform_directory_path, '../example_xls/new_cascading_select_xlsform.org.xlsx'))
        
        warnings= list()
        survey_reimported= self._export_and_reimport(survey_original, 'xls', warnings)
        
        self.assertIn(XlsFormExporter.CASCADING_SELECT_WARNING, warnings)
        
        for child_original, child_reimported in \
          zip(survey_original['children'], survey_reimported['children']):
            if isinstance(child_original, MultipleChoiceQuestion) and child_original.is_cascading_select():
                cascading_select_question= child_reimported # Alias
                
                # Assert that a choice is provided.
                self.assertIn('children', cascading_select_question)
                
                # Ensure exactly one choice is provided.
                question_choices= cascading_select_question['children']
                self.assertEqual(len(question_choices), 1)
                
                # Check that the choice correctly warns the user of an incomplete import.
                self.assertEqual(question_choices[0]['name'], XlsFormExporter.CASCADING_SELECT_SAD_CHOICE_NAME)
                self.assertEqual(question_choices[0]['label'], XlsFormExporter.CASCADING_SELECT_SAD_CHOICE_LABEL)


    def test_import_export_filelike_obj(self):
        '''
        Test that XLSForms can be imported from and exported to file-like objects. 
        '''

        xls_survey_path= os.path.join(self.xform_directory_path, '../example_xls/new_cascading_select_xlsform.org.xlsx')
        xls_survey_from_path= survey_from.xls(path=xls_survey_path)
        with open(xls_survey_path) as f:
            xls_survey_from_file_obj= survey_from.xls(filelike_obj=f)
        self.assertEqual(xls_survey_from_path, xls_survey_from_file_obj)

        csv_temp_file= NamedTemporaryFile(suffix='-pyxform.csv')
        xls_survey_from_path.to_csv(path=csv_temp_file.name)
        csv_survey_from_path= survey_from.csv(path=csv_temp_file.name)
        with open(csv_temp_file.name) as f:
            csv_survey_from_file_obj= survey_from.csv(filelike_obj=f)
        self.assertEqual(csv_survey_from_path, csv_survey_from_file_obj)
        
        xls_temp_file= NamedTemporaryFile(suffix='-pyxform.xls')
        xls_survey_from_path.to_xls(path=xls_temp_file.name)
        xls_survey_reimport= survey_from.xls(path=xls_temp_file.name)
        xls_filelike_obj= survey_from.xls(path=xls_temp_file.name).to_xls()
        xls_survey_reimport_filelike_obj= survey_from.xls(filelike_obj=xls_filelike_obj)
        # FIXME: Though these surveys generate identical output 'Survey.__eq__' does not recognize them as equal. 
#         self.assertDictEqual(xls_survey_from_path, xls_survey_reimport_filelike_obj)
        self.assertMultiLineEqual(xls_survey_reimport.to_xform().read(), xls_survey_reimport_filelike_obj.to_xform().read())
        
        csv_filelike_obj= csv_survey_from_path.to_csv()
        csv_survey_reimport= survey_from.csv(filelike_obj=csv_filelike_obj)
        self.assertEqual(csv_survey_from_path, csv_survey_reimport)


    def test_export_group(self):
        '''
        Test that groups can be exported to XLSForms.
        '''
        
        warnings= list()
        survey_path= os.path.join(self.xform_directory_path, 'Simple_group_form.xml')
        
        survey_csv_stringio= survey_from.xform(survey_path).to_csv(warnings=warnings)
        survey_csv_reimported= survey_from.csv(filelike_obj=survey_csv_stringio)
        
        # Ensure that the user is warned about the experimental nature of exporting groups.
        self.assertIn(survey_to_xlsform.GROUP_EXPORT_WARNING, warnings)
        
        # Ensure that the expected group is present and recognized as the correct type.
        expected_group_name= 'group_bt9cr48'
        for child in survey_csv_reimported.children:
            if child['name'] == expected_group_name:
                self.assertTrue(isinstance(child, GroupedSection))
                break
        else:
            raise RuntimeError('Group "{}" not found in reimported CSV survey.'.format(expected_group_name))
        
        # Ensure that the reimported CSV correlates to the original XForm.
        with open(survey_path) as original_survey_file:
            self.assertMultiLineEqual(original_survey_file.read(), survey_csv_reimported.to_xform().read())


if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.testName']
    unittest.main()
